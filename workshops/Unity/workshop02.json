{
    "title": "Workshop 02",
    "description": "",
    "thumbnail": "",
    "videoUrl": "https://www.youtube.com/embed/0aCGgcHzxvM",
    "tableOfContents": [
        "Intro to Prefabs",
        "Getting Started",
        "Creating a Fancy Cube",
        "Reusing our Fancy Cube",
        "Collecting our Fancy Cube",
        "Unity Coroutines",
        "Enemies",
        "NavMesh and NavMeshAgent",
        "Creating a Enemy Prefab",
        "Generic Enemy Behaviour",
        "Specialising our Enemies",
        "Creating a Spawner",
        "Finishing Touches"
    ],
    "contents": [
        {
            "type": "heading",
            "title": "Errata"
        },
        {
            "type": "infopoint",
            "body": []
        },
        {
            "type": "heading",
            "title": "Flatpack GameObjects"
        },
        {
            "type": "tutstep",
            "title": "Intro to Prefabs",
            "body": "Sometimes we want to have an army of clones. From enemies, to powerups, to collectibles, we often need identical copies of a certain game object, without having to manually place each one. Luckily Unity allows us to do just that in the form of \"prefabs\".\n\nA prefab is just a game object template based on which we can create real game objects in the current scene. This is called \"instantiating\" a prefab, and can be done through the `GameObject.Instantiate(GameObject, ...)` methods. The distinction between a prefab and a game object is similar to the distinction between a class and an instance in OOP, with the class being a template based on which concrete instances are created. The prefab declares the components that a GameObject will have, and the starting values for said components, and can be used to create copies of the specified GameObject (via a call to `GameObject.Instantiate`).\n\nAdditionaly there exist so-called prefab variants for when you want to \"inherit\" from a prefab and create a more specialised version (i.e. creating a ranged enemy from the base enemy prefab). This approach is really useful for declaring common components, but having separate component starting values for each subtype.\n\n"
        },
        {
            "type": "tutstep",
            "title": "Getting Started",
            "body": "As usual, we start off by creating a branch that will store a snapshot of our\nwork:\n```sh\n$ git branch workshop02\n$ git checkout workshop02\n```\n\nThen, open up the project in the Unity Editor.\n\n"
        },
        {
            "type": "heading",
            "title": "Fancy Cubes and Scorekeeping"
        },
        {
            "type": "tutstep",
            "title": "Creating a Fancy Cube",
            "body": "An excellent use case for prefabs is spawning many identical game objects for the player to collect to increase their \"score\", or as powerups scattered throughout a level. We can create a single template for our collectibles, and then instantiate them as needed (either by dragging them into the hierarchy and arranging them in the scene manually, or from code). First, we need a base game object to use as this template, so we will make a friendly yellow rotating cube.\n\n1. Create a new 3D Cube in the Hierarchy pane, naming it Item or something similar. Select it to open it in the Inspector pane\n2. Set its position such that it does not intersect with any other game objects already present\n3. Set its scale to 0.5 in all axes to decrease its volume\n4. Goto Assets in the Project pane and create a new folder called Materials. Enter it and create a new material called ItemMaterial. Set the \"Main Map > Albedo\" field to a nice yellow colour\n5. Drag the new material onto the Item game object in the hierarchy\n6. Goto Assets/Scripts in the Project pane and create a new script called Rotator. Open it in your favourite text editor\n7. Replace the contents of the script with the following\n```cs\nusing UnityEngine;\n\npublic class Rotator : MonoBehaviour {\n}\n```\n8. Add a new serialized private variable to hold the rotation vector\n```cs\n[SerializeField] private Vector3 rotation;\n```\n9. Add the FixedUpdate method, to apply the rotation to the parent game object's transform\n```cs\nprivate void FixedUpdate() {\n   transform.Rotate(rotation * Time.fixedDeltaTime);\n}\n```\n10. Save the script and return to the Unity Editor. Add the script component to the Item game object, set the rotation to some value (e.g. 15,30,45), save the scene, and press \"Play\" to enter play mode and test out the functionality of the cube. It should rotate by the given amount each second\n\n"
        },
        {
            "type": "tutstep",
            "title": "Reusing our Fancy Cube",
            "body": "Having made an eye-catching rotating cube, we might want to have multiple copies in the scene at once for the player to collect. One way of doing this is by simply pasting the current instance many times into the scene. Whilst simple, this means that if we want to change an aspect of the cube we need to manually edit all instances currently in the scene. A much more maintainable way is to create an Item prefab, and then spawn multiple instances of said prefab into the scene. Later, by editing the base prefab, all instances will be affected by the changes!\n\n1. Goto Assets in the Project pane and create a new folder called Prefabs. Enter it\n2. Drag the Item game object from the Hierachy pane to the Prefabs folder. This will create a new prefab from the given game object. Double click it to enter the prefab editor\n3. Add a collider to the prefab, setting it to be a trigger collider. Save the prefab, then click the \"<\" arrow near the top of the Hierarchy pane to return to the regular scene editor\n4. To organise our collectibles centrally, create a new empty game object named \"Collectibles Parent\" in the root of the scene in the Hierarchy pane. Reset its position to 0,0,0\n5. Drag the Item prefab from the Project pane into the Hierachy pane to instantiate a new game object from the prefab. Set its position to somewhere in the scene that does not intersect with any existing game objects\n6. Do this a few more times until there are at least 3 Item prefab instances in the scene at different locations\n\n"
        },
        {
            "type": "tutstep",
            "title": "Collecting our Fancy Cube",
            "body": "We now have multiple instances of our fancy rotating cubes in the scene, but they still do not interact with the player in any way. To remedy this, it would be nice for the player to be able to pick up the cubes, and have some abstract \"score\" increase. For now, we will simply log this score to the console, but later we might add a UI for the player to have visual feedback on the number of cubes they have collected.\n\n1. Create an empty child game object on the Player game object in the Hierachy pane, naming it Collectibles\n2. Goto Assets/Scripts in the Project pane and create a new script called \"Collector\". Open it in your favourite text editor\n3. Replace the contents of the script with the following\n```cs\nusing UnityEngine;\n\n[RequireComponent(typeof(Collider))]\npublic class Collector : MonoBehaviour {\n}\n```\n4. Add a private variable to store the game object to which picked up items are reparented when they are collected\n```cs\nprivate GameObject statefulItemRoot;\n```\n5. Add a new property to store the player's current \"score\", or the number of cubes they have collected\n```cs\npublic int Score { get; set; }\n```\n6. Add the Start method to create the collected item parent game object\n```cs\nprivate void Start() {\n   statefulItemRoot = Instantiate(new GameObject(), transform);\n   statefulItemRoot.name = \"Stateful Item Root\";\n}\n```\n7. Add the OnTriggerEnter method to actually pick up the collectibles. Since the \"Collector\" game object is on the default layer, it will pick up anything that it comes in contact with. This will be fixed in a second\n```cs\nprivate void OnTriggerEnter(Collider other) {\n   other.transform.parent = statefulItemRoot.transform;\n   other.gameObject.setActive(false);\n\n   Score += 1;\n   Debug.Log($\"Current Score: {score}\");\n}\n```\n8. Save the script and return to the Unity Editor. Select the Collectibles game object under the Player game object, and attach the newly created script component to it in the Inspector. This should automatically attach a collider, but attach one if this is not the case. Make sure to set this collider to be a trigger collider\n9. Put the Collectibles game object on a new \"Collectable\" layer\n10. Open the Item prefab in the prefab editor, and place this on the new \"Collectable\" layer as well\n11. Goto \"Edit > Project Settings > Physics\" and edit the collision layer matrix such that colliders on the \"Collectable\" layer only interact with other colliders on the same layer. This will make sure that the only game objects the player \"Collectibles\" child object will collide with are the Item instances\n12. Save the scene and press \"Play\" to enter play mode to test out the game. The player should be able to run into the Item instances and collect them, with the running total being displayed in the console\n\n"
        },
        {
            "type": "tutstep",
            "title": "Unity Coroutines",
            "body": "Sometimes we want certain methods to be called after a certain delay, or to otherwise schedule the order of some operations. This can be done in the Update function, by appending the time delta per frame to a \"counter\" variable, and checking to see if the passed time exceeds some threshold. This works, but unfortunately means having both floating point errors (addition on float and double is imprecise) and doing unnecessary CPU work (granted this is marginal in this case, but there is a way to avoid it).\n\nThe cleaner solution is to utilise \"coroutines\". Coroutines are essentially restartable functions, where the `yield` keyword shows at what point execution of the function will be \"paused\", and at which point execution of the function will resume when Unity resumes handling your coroutine. Once the end of a coroutine is reached, it wont ever be resumed. A simple coroutine can be written as follows:\n\n```cs\nprivate IEnumerator MyCoroutine() {\n   Debug.Log(\"Doing work!\");\n\n   yield return new WaitForSeconds(2);\n\n   Debug.Log(\"Doing more work after 2 seconds!\");\n}\n```\n\nCoroutines can be thought of as code running in parallel on a separate thread (except that multiple coroutines are multiplexed onto a small threadpool managed by Unity). Unity supports delaying coroutines; by yielding a new WaitForSeconds object the coroutine will be paused, and continue after the stated delay. Additionally there exists a WaitForSecondsRealtime if one wishes to use unscaled time.\n\n"
        },
        {
            "type": "heading",
            "title": "Artificial (Semi-)Intelligence"
        },
        {
            "type": "tutstep",
            "title": "Enemies",
            "body": "Apart from collectibles and powerups, another great use of prefabs is for enemies. Since most enemies will be carbon copies of each other anyway, and there would ideally be endless hordes of them for the player to butcher, we are unable to manually place all of them. Thus, we want to instantiate a copy of an enemy when and where we need it.\n\n"
        },
        {
            "type": "tutstep",
            "title": "NavMesh and NavMeshAgent",
            "body": "Enemies are not much fun if they are simply static sentries (they are doubly unfun if they are static *melee* sentries). Thus, they need to have some way of moving towards the player. In 2D, this is quite simple to do with a script (simply face the player and add a forwards velocity vector to the player). In 3D, it gets a bit harder (still possible to use the 2D approach by ignoring the Y axis), which is where the NavMesh comes in!\n\nThe NavMesh (and associated NavMeshAgent) allows a game object to intelligently navigate through some scenery to a given target position. By writing a simple script to constantly update said target position to the position of the player's transform, it is possible to easily track the player. Of note is the customisation potential of the NavMesh, with the size of the game object being controlled, its minimum distance from the edges of the navigation mesh, points where it can jump to other parts of the mesh, and others being easily tweakable via the Inspector.\n\nThe NavMeshAgent component is the part of the navigation system which gets added to game objects. The NavMesh refers to the mesh built from the scene geometry, on which the Agent components will perform calculations to reach the target position.\nBefore using a NavMesh, it is necessary to \"bake\" it. Before baking you can select which parts of the scene should be considered as the walkable surface.\n\n"
        },
        {
            "type": "tutstep",
            "title": "Creating a Enemy Prefab",
            "body": "1. Create a new Cube in the Hierarchy pane, naming it \"Enemy\" or similar, and select it\n2. Create a new folder named \"Prefabs\" under Assets in the Project pane\n3. Goto Assets/Prefabs and drag the previously created enemy game object into the Project pane. This will create a new prefab\n4. Create a new folder named \"Materials\" under Assets in the Project pane\n5. Goto Assets/Materials, right click and create a new material. Name it EnemyMaterial and change its \"Albedo\" field in the Inspector to Red. Create another material (named EnemyMaterial 2)\n6. Drag the EnemyMaterial onto the enemy game object in the Hierarchy\n7. Drag the enemy game object into the Prefab folder in the Project pane, and create a new prefab variant\n8. Double click on the original enemy prefab, to open it in the prefab editor. Add a NavMeshAgent component to it. Notice how this component also got added to the variant\n9. Further add a Rigidbody component, setting it to Kinematic. Since this rigidbody will not be controlled by the physics system, but by an external script (in this case the NavMeshAgent), it must be Kinematic so that it still interacts correctly with other rigidbodies. Add a child game object called \"Detection Area\". Create a new layer called \"Detectable\", and set the layer of the \"Detection Area\" game object to said layer\n10. Select the player game object in the Hierarchy pane, and add a child game object called \"Detection Point\". Set its layer to \"Detectable\" as well\n11. Goto Assets/Scripts in the Project pane and create a new script called EnemyMovement. Open it in your favourite text editor\n12. Replace the contents of the script with the following\n```cs\nusing System;\nusing UnityEngine;\nusing UnityEngine.AI;\n\n[RequireCompoennt(typeof(NavMeshAgent))]\npublic class EnemyMovement : MonoBehaviour {\n}\n```\n13. Create 3 new private variables to store a reference to the enemy game object's NavMeshAgent component, whether the agent is paused, and the stopping distance of the agent\n```cs\nprivate NavMeshAgent enemyNavMeshAgent;\nprivate bool isPaused = false;\nprivate float stoppingDistance;\n```\n14. Create a new property to allow other scripts to set the stopping distance\n```cs\npublic float StoppingDistance {\n   private get {\n      return stoppingDistance;\n   }\n\n   set {\n      stoppingDistance = value;\n      enemyNavMeshAgent.stoppingDistance = value;\n   }\n\n}\n```\n15. Create a new property to allow other scripts to set the enemy target transform\n```cs\npublic Transform Target { private get; set; }\n```\n16.  Add the Awake method, fetching and caching a reference to the enemy game object's NavMeshAgent component\n```cs\nprivate void Awake() {\n   enemyNavMeshAgent = GetComponent<NavMeshAgent>();\n}\n```\n17. Add a new event to allow other scripts to react when the enemy reaches its target\n```cs\npublic event Action<Vector3, Action> ReachedTarget;\n```\n18. Add the FixedUpdate method, with the following lines\n```cs\nprivate void FixedUpdate() {\n   if (isPaused || Target == null) {\n      return;\n   }\n\n   if (Vector3.Distance(transform.position, Target.position) < StoppingDistance) {\n      ReachedTarget?.Invoke(transform.position, Resume);\n      isPaused = true;\n   } else {\n      enemyNavMeshAgent.destination = Target.position;\n   }\n}\n```\n19. Add a Resume method to unpause the agent\n```cs\nprivate void Resume() {\n   isPaused = false;\n}\n```\n20. Save the script and return to the Unity Editor.\n\n\n"
        },
        {
            "type": "tutstep",
            "title": "Generic Enemy Behaviour",
            "body": "At this point we have a basic movement script for enemies, driven by NavMeshAgent, but we do not have any way of defining their behaviour. Thinking about it, we can notice that all enemies share certain traits. For example, they will all have an \"active range\" within which they will spot, track, and attack the player. They should also all have a cooldown between attacks, to ensure that they cannot stunlock or otherwise cheat the player. To model this, we might want to create a base class for all enemy behaviours from which more specialised behaviours derive.\n\nIn this base class, we will use abstract and virtual methods. These were cautioned against in the C# primer in workshop 01, for the reason that they can negatively impact performance when used in large numbers, and that they hide the fact that the magic method is still called. Here, however, the abstract method is the responsibility of the child class and must be implemented (otherwise the script will not compile), and the virtual methods will do some work by default (increasing/decreasing the tracking range as required). Thus no empty method is hidden, and this usage is mostly fine.\n\n1. Goto Assets/Scripts in the Project pane and create a new script called EnemyBehaviourBase. Open it in your favourite text editor\n2. Replace the contents of the script with the following\n```cs\nusing System;\nusing UnityEngine;\n\n[RequireComponent(typeof(SphereCollider))]\npublic abstract class EnemyBehaviourBase : MonoBehaviour {\n}\n```\n3. Create a new private variable to store a reference to the range collider\n```cs\nprivate SphereCollider enemyTrackingRangeCollider;\n```\n4. Create 4 new serialised private variables to store enemy tracking range, attack range, and attack cooldown\n```cs\n[SerializeField] private float baseTrackingRange;\n[SerializeField] private float activeTrackingRange;\n[SerializeField] private float attackRange;\n[SerializeField] private float attackCooldown;\n```\n5. Create 4 new properties to manage the tracked game object (read: player game object), the enemy movement controller, and the attack range and cooldown\n```cs\nprotected GameObject TrackedGameObject { get; set; }\nprotected EnemyMovement MovementController { get; private set; }\npublic float AttackRange { get { return attackRange; } }\npublic float AttackCooldown { get { return attackCooldown; } }\n```\n6. Add the Awake method to fetch and cache a reference to the enemy game object's movement controller component. This is a call to GetComponentInParent<T>() since this script needs to be placed on a layered trigger collider, and the parent enemy game object might want to be on a different layer. Further, this (and the other) magic method is protected instead of private to ensure that derived behaviours do not accidentally override the implementation (a warning will display in Visual Studio, notifying you if this is the case)\n```cs\nprotected virtual void Awake() {\n   enemyTrackingRangeCollider = GetComponent<SphereCollider>();\n\n   MovementController = GetComponentInParent<EnemyMovement>();\n}\n```\n7. Add the Start method to set the stopping distance property on the MovementController\n```cs\nprotected virtual void Start() {\n   enemyTrackingRangeCollider = baseTrackingRange;\n\n   MovementController.StoppingDistance = attackRange;\n}\n```\n8. Add the OnEnable and OnDisable methods to assign and deassign the MovementController.ReachedTarget event handler\n```cs\nprotected virtual void OnEnable() {\n   MovementController.ReachedTarget += OnReachedTarget;\n}\n\nprotected virtual void OnDisable() {\n   MovementController.ReachedTarget -= OnReachedTarget;\n}\n```\n9. Add the handler method as an abstract method, to be implemented per-subclass\n```cs\nprotected abstract void OnReachedTarget(Vector3 position, Action resumeTrackingCallback);\n```\n10. Add the OnTriggerEnter and OnTriggerExit methods to track when other game objects on the same layer come in and out of range\n```cs\nprotected virtual void OnTriggerEnter(Collider other) {\n   if (other.tag == \"Player\" && TrackedGameObject == null) {\n      enemyTrackingRangeCollider.radius = activeTrackingRange;\n   }\n}\n\nprotected virtual void OnTriggerExit(Collider other) {\n   if (other.gameObject == TrackedGameObject) {\n      enemyTrackingRangeCollider.radius = baseTrackingRange;\n   }\n}\n```\n11. Save the script and return to the Unity Editor\n\n"
        },
        {
            "type": "tutstep",
            "title": "Specialising our Enemies",
            "body": "Having finished the base enemy behaviour, we need to create individual behaviour scripts for our different enemy types. For now we will only implement melee enemies and ranged enemies, but feel free to implement spawner enemies, support enemies, and any other type you can think of. To create a derived behaviour you simply need to derive from the abstract EnemyBehaviourBase class, and implement the OnReachedTarget method.\n\n1. Goto Assets/Scripts in the Project pane and create two new scripts called EnemyBehaviourMelee and EnemyBehaviourRanged. Open EnemyBehaviourMelee in your favourite text editor\n2. Replace the contents of the script with the following\n```cs\nusing System;\nusing System.Collections;\nusing UnityEngine;\n\npublic class EnemyBehaviourMelee : EnemyBehaviourBase {\n}\n```\n3. Add the AttackCoroutine method\n```cs\nprivate IEnumerator AttackCoroutine(Action resumeTrackingCooldown) {\n   yield return new WaitForSeconds(AttackCooldown);\n\n   resumeTrackingCooldown();\n}\n```\n4. Override the OnReachedTarget, OnTriggerEnter, and OnTriggerExit methods with the following implementations. OnReachedTarget uses a discard variable to remind us that StartCoroutine returns a handle to the coroutine, but this could be omitted\n```cs\nprotected override void OnReachedTarget(Vector3 position, Action resumeTrackingCallback) {\n   _ = StartCoroutine(AttackCoroutine(resumeTrackingCallback));\n}\n\nprotected override void OnTriggerEnter(Collider other) {\n   if (other.tag == \"Player\" && TrackedGameObject == null) {\n      TrackedGameObject = other.gameObject;\n      MovementController.Target = other.transform;\n   }\n\n   base.OnTriggerEnter(other);\n}\n\nprotected override void OnTriggerExit(Collider other) {\n   if (other.gameObject == TrackedGameObject) {\n      TrackedGameObject = null;\n      MovementController.Target = null;\n   }\n\n   base.OnTriggerExit(other);\n}\n```\n5. Save the script, and copy-paste its contents into the EnemyBehaviourRanged script. Save that script and return to the Unity Editor\n6. Select the Player object in the Hierarchy pane, and set its tag to \"Player\" in the Inspector pane\n7. Goto Assets/Prefabs in the Project pane, and double click the original enemy prefab to open it in the prefab editor\n8. Add the EnemyMovement script component to the parent Enemy game object\n9. Add the EnemyBehaviourMelee script component to the Detection Area child game object. This should add a SphereCollider component by default (if it does not, then add it manually)\n10. Set default values for the fields on the prefab, then save it and open the enemy prefab variant in the prefab editor\n11. Remove the EnemyBehaviourMelee script component from the Detection Area child game object, and add on a EnemyBehaviourRanged script component in its place. Add a SphereCollider if it is not added manually\n12. Save the prafab and add instances of both prefabs to the scene by dragging them into the Hierachy pane. Press \"Play\" to test the game. You should be able to navigate towards enemies, and they should react when you go into and out of range by following you or stopping following you respectively\n13. Exit play mode when you are finished with testing\n\n"
        },
        {
            "type": "tutstep",
            "title": "Creating a Spawner",
            "body": "1. Create a new Sphere in the Hierarchy pane, naming it Spawner or similar\n2. Select the Spawner game object in the Hierarchy pane, and add a Rigidbody component to it. Make the Rigidbody kinematic\n3. Add a NavMeshObstacle component to the Spawner game object\n4. Goto Assets/Scripts and create a new script called Spawner. Open it in your favourite text editor\n5. Replace the contents of the script with the following\n```cs\nusing System.Collections;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour {\n}\n```\n6. Add the following serialized private variables to hold the prefabs the spawner will instantiate, the cooldown between spawns, the minimum and maximum bounds of its spawn radius, the height at which objects will be spawned, and whether the spawner repeats\n```cs\n[SerializeField] private GameObject[] sourcePrefabs;\n[SerializeField] private float cooldownSeconds;\n[SerializeField] private float maxSpawnRadius;\n[SerializeField] private float minSpawnRadius;\n[SerializeField] private float spawnHeight;\n[SerializeField] private bool repeat;\n```\n7. Add a private variable to hold whether the spawner is currently active or not\n```cs\nprivate bool isActive = false;\n```\n8. Add the Start method\n```cs\nprivate void Start() {\n   StartSpawner();\n}\n```\n9. Add the RandomPositionInRing method. It generates and returns a random position within the spawn ring defined by the minSpawnRadius and maxSpawnRadius\n```cs\nprivate Vector3 RandomPositionInRing() {\n   float theta = Random.Range(0, 2 * Mathf.PI);\n   float hypot = Random.Range(minSpawnRadius, maxSpawnRadius);\n\n   float x = hypot * Mathf.Sin(theata), z = hypot * Mathf.Cos(theta);\n\n   return new Vector3(x, spawnHeight, z);\n}\n```\n10. Add the SpawnerCoroutine method. Of note is the fact that Instantiate returns a reference to the newly created game object (which we place in the discard `_`). This can be used to keep track of spawned game objects (by placing them in a list) to stop spawning when `n` objects are alive, or it could be used to tweak values in the created game object's component. We simply ignore the game object and continue with our coroutine\n```cs\nprivate IEnumerator SpawnerCoroutine() {\n   isActive = true;\n\n   int sourcePrefabIndex = 0;\n   do {\n      yield return new WaitForSeconds(cooldownSeconds);\n\n      _ = Instantiate(sourcePrefabs[sourcePrefabIndex++], RandomPositionInRing(), transform.rotation);\n      sourcePrefabIndex %= sourcePrefabs.Length;\n   }\n\n   isActive = false;\n}\n```\n11. Add the SpawnerStart and SpawnerStop methods\n```cs\npublic void StartSpawner() {\n   repeat = true;\n\n   if (!isActive) {\n      _ = StartCoroutine(SpawnerCoroutine());\n   }\n}\n\npublic void StopSpawner() {\n   repeat = false;\n}\n```\n12. Save the script and return to the Unity Editor. Select the Spawner game object and add the Spawner script component\n13. Drop down the \"Source Prefabs\" field on the Spawner component in the Inspector pane, and set the Size field to 2\n14. Goto Assets/Prefabs and drag both enemy prefabs from the Project pane to the new spaces for game objects\n15. Populate the rest of the fields as you see fit, and press \"Play\" to enter play mode and test the game. The spawner should be spawning new enemies within the bounds you defined\n\n"
        },
        {
            "type": "tutstep",
            "title": "Finishing Touches",
            "body": "We start tracking our changed files, and push them to the remote branch:\n```sh\n$ git add .\n$ git commit -m \"Finished workshop 2\"\n$ git push -u origin workshop02\n$ git checkout main\n```\n\nOnce the changes have been pushed, go to your remote git repository and merge the changes onto the main branch. Once the changes have been successfully merged, feel free to go back and delete the (now stale) local workshop01 branch.\n```sh\n$ git branch -d workshop02\n$ git pull\n```\n\n"
        }
    ]
}