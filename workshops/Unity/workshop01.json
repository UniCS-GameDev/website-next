{
    "title": "Workshop 01",
    "description": "",
    "thumbnail": "",
    "videoUrl": "",
    "tableOfContents": [
        "Some foundational C#",
        "Unity and Magic Methods",
        "Rigidbody",
        "Collider",
        "Getting Started",
        "Basic Movement",
        "Jumping",
        "Crouching and Sprinting",
        "Creating a Tracking Camera",
        "Finishing Off"
    ],
    "contents": [
        {
            "type": "heading",
            "title": "Errata"
        },
        {
            "type": "infopoint",
            "body": []
        },
        {
            "type": "heading",
            "title": "Intro to Scripting"
        },
        {
            "type": "tutstep",
            "title": "Some foundational C#",
            "body": "C# is a heavily object oriented language. In C#, there can be no naked members (e.g. variables, methods, properties, events, indexers); everything must reside within a User Defined Type (known as a UDT), of which there are 3:\n\n* Classes\n* Structs\n* Interfaces\n\nFurthermore, there are also 2 special types that can be defined by the user:\n* Enumerations\n* Delegate\n\nFinally, all types in C# come packaged in an \"Assembly\". This can be thought of as C#'s equivalent to Java packages or Python modules. Generally, the assembly will have the same name as the root namespace of its types, but this is not mandated by the specification. For example, you can have the root namespace \"FooBar\" in the assembly \"MyAssembly\"; in this case you must use `using FooBar.xyz;` instead of `using MyAssembly.xyz;`.\n\n#### Classes\nGeneric container for members. Classes in C# are similar to Java, and are declared as follows:\n```cs\npublic class Foo {\n    private int myVariable;\n\n    // Visible to all types in any assembly\n    public void MethodA() { }\n\n    // Visible only to all types in same assembly\n    internal void MethodB() { }\n\n    // Visible to all subtypes of Foo in any assembly\n    protected void MethodC() { }\n\n    // Union of internal and protected; visible to all types in same assembly \n    // and to all subtypes of Foo in any assembly\n    protected internal void MethodD() { }\n\n    // Visible only to subtypes of Foo in same assembly\n    private protected void MethodE() { }\n\n    // Visible only to this class and nested classes/structs\n    private void MethodF() { }\n}\n\n// Top-level UDTs can only come with 'public' or 'internal' access modifiers\n// The default if the modifier is omitted is 'internal'\ninternal class MyType {\n    // ...\n}\n```\n\nIn addition to methods and variables, C# supports properties:\n```cs\npublic class Foo {\n    // A basic property is declared as follows\n    public string MyProperty { get; set; }\n\n    // Properties may have access modifiers on their getters and setters\n    public string MyProperty2 { public get; private set; }\n\n    // Readonly properties can also be declared, which only support being \n    // assigned in the constructor. This is not that applicable to Unity and \n    // its MonoBehaviour, but is more useful in UDTs\n    private int MyProperty3 { get; }\n\n    public void Example() {\n        MyProperty = \"Hello, World!\"; // Assigning to properties\n        string myString = MyProperty; // Reading from properties\n    }\n}\n```\n\n#### Structs\nStructs in C# are very similar to classes, except that they live on the stack instead of the heap. This makes them cheap to access, but due to the copying that must be done when they are passed to methods, they should be used only if they are 16 bytes in size or less. Otherwise, it is more efficient to use a class (the passing of which to a method only requires copying a reference).\n\nAdditionally, structs have value semantics (whereas classes have reference semantics), meaning that whenever a struct is assigned, passed as an parameter to a method, or returned from a method, a copy of the struct is made. This can catch you out, so it might be easier to use a class instead (which can be more intuitive). Alternatively, you could declare an *immutable struct*, which only allows readonly variables and properties.\n\nStructs are declared as follows:\n```cs\npublic struct Bar {\n    // Since structs live on the stack, accessing their variables is very fast. \n    // Since properties are syntactic sugar around method calls, structs are \n    // one of the few times it is ok to use a public variable\n    public int MyInt;\n\n    // The only access modifiers allowed in structs are:\n    public void MethodA() { }\n    internal void MethodB() { }\n    private void MethodC() { }\n}\n\n// Readonly (immutable) structs are declared as follows\npublic readonly Bar2 {\n    // All variables and properties in an immutable struct must be labelled as \n    // readonly, and thus can only be assigned in the constructor\n    public readonly int MyInt;\n    public readonly int MyIntProperty { get; private set; }\n}\n```\n\n#### Interfaces\nInterfaces can be thought of as a contract, that declares the methods and properties which will be available on any *implementor* of the interface. When a class or struct implements an interface, any members declared in the interface must be present in the implementer as a public member. This means that a user of the implementer is guaranteed to be able to use the members defined in the interface on any implementer of the interface.\n\nNOTE: Interfaces do not generally support variables or defining methods with implementations directly in the interface. C# 8.0 allows for default implementations in interfaces, but this language version is unavailable in Unity by default.\n\nInterfaces are declared and used as follows:\n```cs\npublic interface IMyInterface {\n    // Note that in an interface, you must omit the access modifier, since all \n    // declared members must be declared public on the implementer\n    void MyMethod();\n    float Foo();\n    int MyProperty { get; set; }\n\n\n    // If a getter or setter is present in a property declaration in an \n    // interface, the getter or setter must be public in the implementers \n    // declaration. However if one is omitted then the implementer is free to \n    // give it or not (and thus is free to give it any access modifier)\n    int MyProperty2 { get; }\n}\n\npublic class Implementer : IMyInterface {\n    // This must be implemented\n    public void MyMethod() { }\n\n    // Alternatively one can use so-called explicit interface implementations, \n    // which mean that the 'public' access modifier can be omitted. These are \n    // mainly necessary when a type implements multiple interfaces, both of \n    // which contain a member with an identical signature (name + parameters)\n    // this function will have an implicit access modifier of public\n    float IMyInterface.Foo() { return 0.0; }\n\n    // Likewise this must be implemented, with no access modifiers on the \n    // getter or setter\n    public int MyProperty { get; set; }\n\n    // This must be implemented, but can have any access modifier on the setter \n    // (as it was omitted in the interface)\n    public int MyProperty2 { get; private set; }\n}\n```\n\n#### Enumerations\nEnumerations are essentially a type which allows only a fixed set of values. They are conceptually similar to a combo-box html input, in that you can only set the value of a enum variable to one of the enum's declared members. A good use for enumerations is modelling a fixed number of states, or options. Another good use is managing bitfields.\n\nEnumerations are declared as follows:\n```cs\npublic enum Baz {\n    ValueOne,\n    ValueTwo,\n    ValueThree = 2\n}\n\n// Enums can \"inherit\" from any of the following primitive integer types:\n//     char, sbyte, byte, short, ushort, int, uint, long, ulong\n// These enum will use as many bits as the given type. These enums are treated \n// as binary flags, and allow bitwise operations to be performed on them. The \n// following enum can be thought of as a 16-bit wide bitset (ushort is 16-bit)\npublic enum Baz2 : ushort {\n    A = 0,\n    B = 1 << 1,\n    C = 4\n}\n\n// The use of enums is also simple\npublic void Example() {\n    Baz enumValue = Baz.ValueOne;\n\n    if (enumValue == Baz.ValueThree) { }\n\n    switch (enumValue) {\n        case Baz.ValueOne:\n            break;\n        // ...\n    }\n\n    // With bitset enums, you can perform bitwise operations\n    Baz2 bitset = Baz2.A | Baz2.C;\n}\n```\n\n#### Delegate\nA delegate is a type used to represent a function. It is equivalent to a function pointer in C/C++, and allows for storing a reference to a function with a particular set of parameters and return type, to call it at a later point.\n\nCommon delegate types that are used are `Action<TParam>` and `Func<TParam, TResult>`, corresponding to a void returning function that takes a parameter of type TParam, and a function TResult returning function that takes a parameter of type TParam. There also exist variants for up to 8 parameters (any more and you have to declare your own delegate). These exist under the System namespace, so can be used with a simple `using System;` statement at the top of a file.\n\nDeclaring a delegate:\n```cs\n// The delegate can go directly in a namespace, and have any return type that \n// a method can have, as well as any number of parameters\npublic delegate void MyDelegate(int param1, int param2);\n```\n\n#### Events\nEvents are a special member in C# that implements a common software pattern called the \"Observer Pattern\" as part of the language. It allows for classes to register \"event handlers\" that will get invoked whenever a certain \"event\" occurs. A good analogy for this is that of magazine publishers and subscribers.\n\nPublishers frequently push out new editions of a magazine. You might want to subscribe to a certain magazine (or more than one at the same time!), and be notified when a new edition comes out. You only care about getting the latest edition, and you do not care about knowing how the magazine is published or who else is subscribed. You might also want to be able to cancel your subscription to the magazine at any time to stop receiving new editions. If you rejoin at a later date, you want to continue getting new editions from that point on.\n\nWhen an event is declared as a member of a class, it needs to know the signature of the \"event handlers\" that will be subscribed to it. This is achieved using the previously described delegates.\n```cs\npublic class Publisher {\n    public void InvokeEvent(int param) {\n        // Invokes the event with the given parameter only if it is not null. \n        // An event is only null if it does not have any registered handlers\n       if (MyEvent != null) {\n           MyEvent.Invoke(param);\n       }\n\n       // Alternatively, the above 3 lines could be done with the following \n       // line by using the null coalescing operator '?.'\n       // e.g. MyEvent?.Invoke(param)\n\n        // The '?.' operator only is \"synactic sugar\" for the above, and only \n        // calls the method if the preceeding object is not null\n    }\n\n    // Declares an event whose handlers must beassignable to an Action<int>\n    public event Action<int> MyEvent;\n}\n\npublic class Subscriber() {\n    // The handler method must be assignable to the delegate type used with the \n    // event. In this case, this means that the handler must have a void return \n    // type and take a single parameter of type int (the delegate type in use \n    // with MyEvent is Action<int>)\n    private void HandlerA(int param) {\n        Console.WriteLine($\"Handler A: {param}\");\n    }\n\n    private void HandlerB(int param) {\n        Console.WriteLine($\"Handler B: {param}\");\n    }\n\n    public static void Main() {\n            Publisher publisher = new Publisher();\n\n            // At this point, publisher.MyEvent has no registered handlers, and \n            // thus is null and will not be invoked\n            publisher.InvokeEvent(10);\n\n            // Multiple handlers can be assigned to an event\n            Subscriber a = new Subscriber();\n            publisher.MyEvent += a.HandlerA;\n            publisher.MyEvent += a.HandlerB;\n\n            Subscriber b = new Subscriber();\n            publisher.MyEvent += a.HandlerB;\n\n            // This will invoke all currently registered handlers in an \n            // undefined order.\n            // i.e this will invoke a.HandlerA, a.HandlerB, and  b.HandlerB\n            publisher.InvokeEvent(42);\n\n            // From this point on, a.HandlerB will not be raised whenever \n            // the event occurs\n            publisher.MyEvent -= a.HandlerB;\n\n            // NOTE: you can never assign an event handler to an event outside \n            // its parent class. You can only ever append or remove it from \n            // the handler list. Otherwise, you would be able to remove all \n            // other handlers without other code being aware of the change, \n            // breaking a lot of other subscribers\n            // ERR: publisher.MyEvent = a.HandlerA;\n\n            // This will only invoke a.HandlerA and b.HandlerB\n            publisher.InvokeEvent(69);\n    }\n}\n```\n\n"
        },
        {
            "type": "tutstep",
            "title": "Unity and Magic Methods",
            "body": "In order to give scripts the ability to interact with Unity, there are a few so-called \"magic methods\" implemented on MonoBehaviour that are called by Unity at certain points in time. In order for a script to be assignable as a component and do stuff, it must inherit from MonoBehaviour (you cannot assign regular classes as components). Additionally, if a class does not inherit from MonoBehaviour, its magic method will not be called.\n\nThe following common magic methods are available:\n```cs\npublic class MyScript : MonoBehaviour {\n    // Called whenever a script becomes \"active\"\n    public void OnEnable() { }\n\n    // Called once before any Start methods, generally used to cache references \n    // to other components via GetComponent<T>()\n    public void Awake() { }\n\n    // Called once before any Update methods, like Awake() but can access \n    // members of other components knowing that they will be initialised. \n    // In this method we can also search for other game objects, since they \n    // are guaranteed to exist and have had their Awake methods execute\n    public void Start() { }\n\n    // Runs per-frame, used to fetch input (so as to not miss any user input) \n    // and do other important things. If any expensive calls are made here, \n    // they can seriously decrease the framerate\n    public void Update() { }\n\n    // Runs separately from Update (usually 60 times a second) and should be \n    // reserved for physics interaction and less important methods that must \n    // happen regularly\n    public void FixedUpdate() { }\n\n    // Called whenever a script becomes \"inactive\"\n    public void OnDisable() { }\n\n    // Called whenever a script is destroyed\n    public void OnDestroy() { }\n}\n```\n\n\nIf an expensive computation must occur in Update or FixedUpate but does not have to run every frame, consider the following \"modulo-n\" check to reduce its impact:\n```cs\npublic class MyScript : MonoBehaviour {\n    private uint currentFrame = 0, currentFixedFrame = 0;\n    private const uint frameDelay = 5, fixedFrameDelay = 4;\n\n    public void Update() {\n        if (currentFrame++ % frameDelay == 0) {\n            // Intensive code e.g. GetComponent<T>()\n        }\n    }\n\n    public void FixedUpdate() {\n        if (currentFixedFrame++ % frameDelay == 0) {\n            // Intensive code e.g. GetComponent<T>()\n        }\n    }\n}\n```\n\n"
        },
        {
            "type": "infopoint",
            "body": [
                {
                    "type": "tutstep",
                    "title": "Behind the Scenes",
                    "body": "The following methods are called via the use of internal \"Call Lists\", which store all magic methods which should be ticked, and then do so. The creation of these lists happens during the compilation of the Unity project.\n\nThe call lists are the reason for the following scenario being a bad idea:\n```cs\npublic class BaseMonoBehaviour : MonoBehaviour {\n    public virtual void Awake() { /* ... */ }\n    public virtual void Start() { /* ... */ }\n    public virtual void Update() { /* ... */ }\n    public virtual void FixedUpdate() { /* ... */ }\n    // ...\n}\n\npublic class MyBehaviour : BaseMonoBehaviour {\n    public override void Awake() {\n        // Do something\n\n        base.Awake(); // Calls BaseMonoBehaviour.Awake()\n    }\n    \n    // Even though the following methods aren't overriden, they are still \n    // added to Unity's call lists and ticked when necessary\n    // public override void Start() { }\n    // public override void Update() { }\n    // public override void FixedUpdate() { }\n}\n```\n\nThe reason for the above being bad is that the virtual methods are added to Unity's internally managed call lists, and each method will be ticked every frame. Even if the particular MonoBehaviour does not override or implement the method, it will be called. Due to Unity calling across languages (which has an inherent overhead with marshalling/unmarshalling of passed parameters), this call has a non-zero CPU cost, and thus slows down the processing of the frame.\n\n[Source](https://blogs.unity3d.com/2015/12/23/1k-update-calls/)\n\n\n"
                }
            ]
        },
        {
            "type": "heading",
            "title": "Rigidbody and Collider"
        },
        {
            "type": "tutstep",
            "title": "Rigidbody",
            "body": "In Unity, it is perfectly reasonable to have a game object that will be rendered but will not have physics and to have an object that will be rendered and have physics. By default Unity will not attach the Rigidbody component to new game objects, and thus will not include them in a scene's physics simulation. They will not experience gravity, drag, or collisions.\n\nThere are 3 types of rigidbody:\n\n* Dynamic : The default Rigidbody, will experience collisions and will be affected by the physics system\n* Kinematic : This type will experience collisions, but will not be affected by the physics system. It is most often used for game objects whose movement is\ncontrolled by a player script but that must still interact with other physics entities\n* Static : This type will experience collisions, but will not experience physics and should never be moved. Best used for terrain, and static scene elements like buildings or boulders\n\nAn alternative explanation of the 3 different rigidbody types can be found [here](https://www.youtube.com/watch?v=xp37Hz1t1Q8).\n\n"
        },
        {
            "type": "tutstep",
            "title": "Collider",
            "body": "The Collider (or Collider2D) component is the component responsible for detecting when two game objects intersect (that is, collide). Whenever a game object enters another collider, stays within a collider, or exits a collider, a method can be invoked on the game object. This allows for reaction to the surrounding environment, and can also be used to detect whether something has come \"in range\" of a game object.\n\nA colliders behaviour is controlled by 2 things:\n\n* Is it a trigger collider?\n* Which collision layer is it on?\n\nA collider's layer determines what other layers (and therefore colliders) it can interact with. For example, if collider 1 is on layer 1, and collider 2 is on layer 2, collider 1 will only register collisions with collider 2 if layer 1 and layer 2 are set to interact. If the layers do not interact, neither will the colliders.\n\nA trigger collider is one which will not cause two game objects to bounce off each other. It can be used for seeing when some other game object has come \"in-range\" of another one.\n\n"
        },
        {
            "type": "heading",
            "title": "Building our Game"
        },
        {
            "type": "tutstep",
            "title": "Getting Started",
            "body": "As usual, we start off by creating a branch that will store a snapshot of our\nwork:\n```sh\n$ git branch workshop01\n$ git checkout workshop01\n```\n\nThen, open up the project in the Unity Editor.\n\n"
        },
        {
            "type": "tutstep",
            "title": "Basic Movement",
            "body": "1. Select the Cube in the Hierarchy pane\n* If the Cube lacks a collider, make sure to add one\n2. Add a Rigidbody component to the Cube, and under \"Constraints\", freeze the\nrotation on all 3 axes\n3. Goto Assets/Scripts in the Project pane and create a new script called\nPlayerMovement. Open it in your favourite text editor\n4. Replace the contents of the script with the following. The `RequireComponent` attribute means that when the script is added as a component to a game object, if said game object does not already have a Rigidbody component, one will be automatically added\n```cs\nusing UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\npublic class PlayerMovement : MonoBehaviour {\n}\n```\n5. Create a new private variable to store a reference to the player game object's Rigidbody component\n```cs\nprivate Rigidbody playerRigidbody;\n```\n6. Create a new serialised private variable to store player speed\n```cs\n[SerializeField] private float baseSpeed;\n```\n7. Create 2 new private variables to store player input\n```cs\nprivate float xInput = 0, zInput = 0;\n```\n8. Add the Awake method, fetching and caching a reference to the player game object's Rigidbody component\n```cs\nprivate void Awake() {\n    playerRigidbody = GetComponent<Rigidbody>()\n}\n```\n9. Add the Update method, with the following lines\n```cs\nprivate void Update() {\n    xInput = Input.GetAxis(\"Horizontal\");\n    zInput = Input.GetAxis(\"Vertical\");\n}\n```\n10. Add the FixedUpdate method, with the following lines\n```cs\nprivate void FixedUpdate() {\n    Vector3 relativePositionDelta = (xInput * transform.right) + (zInput * transform.forward);\n    relativePositionDelta *= baseSpeed * Time.fixedDeltaTime;\n    playerRigidbody.MovePosition(transform.position + relativePositionDelta);\n}\n```\n11. Save the script and return to the Unity Editor. Select the player game object in the Hierarchy and find the PlayerMovement component in the inspector\n12. Change the \"Speed\" field to some non-zero value (e.g. 5)\n13. Save the scene and press \"Play\" to test the game, and move around using the arrow-keys or WASD\n14. Exit play mode when you are finished with testing\n\n"
        },
        {
            "type": "tutstep",
            "title": "Jumping",
            "body": "1. Goto Assets/Scripts in the Project pane, and open the PlayerMovement script in your favourite text editor\n2. Add 2 new serialised private variables to store player jump force and the input key which will cause the player to jump\n```cs\n[SerializeField] private KeyCode jumpKey;\n[SerializeField] private float jumpImpulse;\n```\n3. Add a new private variable to store whether the player should be able to jump\n```cs\nprivate bool shouldJump = false;\n```\n4. In the Update method add the following lines\n```cs\nprivate void Update() {\n    // ...\n\n    if (Input.GetKeyDown(jumpKey)) {\n        shouldJump = true;\n    } else if (Input.GetKeyUp(jumpKey)) {\n        shouldJump = false;\n    }\n}\n```\n5. In the FixedUpdate method add the following lines\n```cs\nprivate void FixedUpdate() {\n    // ...\n\n    if (shouldJump) {\n        playerRigidbody.AddForce(new Vector3(0, jumpImpulse, 0), ForceMode.Impulse);\n        shouldJump = false;\n    }\n}\n```\n6. Save the script and return to the Unity Editor. Select the player game object in the Hierarchy and find the PlayerMovement component in the inspector\n7. Pick a KeyCode value to use for the jump key (e.g. Space) and pick a jump force (e.g. 5)\n8. Save the scene and press \"Play\" to test the game. Start jumping using the previously assigned key. You should quickly run into a bug where the player can jump infinitely and can therefore fly. Think about why this happens, and perhaps try to implement a fix yourself. A great resource that explains 3 ways of achieving this for 2D can be found [here](https://www.youtube.com/watch?v=c3iEl5AwUF8). Can you extend the given implementations to 3D?\n9. Exit play mode when you are finished with testing\n10. Goto Assets/Scripts in the Project pane and create a new script called Grounder. Open it in your favourite text editor\n11. Replace the contents of the script with the following\n```cs\nusing UnityEngine;\n\n[RequireComponent(typeof(Collider))]\npublic class Grounder : MonoBehaviour {\n}\n```\n12. Add 2 events to the class, named TouchedGround and LeftGround\n```cs\npublic class Grounder : MonoBehaviour {\n    public event Action<Collider> TouchedGround;\n    public event Action<Collider> LeftGround;\n}\n```\n13. Add the OnTriggerEnter method, invoking the TouchedGround event if it is not null (if it has registered subscribers)\n```cs\nprivate void OnTriggerEnter(Collider other) {\n    TouchedGround?.Invoke(other);\n}\n```\n14. Add the OnTriggerExit method, invoking the LeftGround event if it is not null (if it has registered subscribers)\n```cs\nprivate void OnTriggerExit(Collider other) {\n    LeftGround?.Invoke(other);\n}\n```\n15. Save the Grounder script and open the PlayerMovement script in your favourite text editor\n16. Add a serialized private variable to store a reference to the player game object's Grounder component\n```cs\n[SerializeField] private Grounder playerGrounder;\n```\n17. Add a private variable to store whether the player is grounded or not\n```cs\nprivate bool isGrounded = false;\n```\n18. Add the OnTouchedGround and OnLeftGround methods, which will be handlers for the Grounder events\n```cs\nprivate void OnTouchedGround(Collider other) {\n    isGrounded = true;\n}\n\nprivate void OnLeftGround(Collider other) {\n    isGrounded = false;\n}\n```\n19. Add the OnEnable method, which registers the OnTouchedGround and OnLeftGround methods as handlers for the Grounder events\n```cs\nprivate void OnEnable() {\n    playerGrounder.TouchedGround += OnTouchedGround;\n    playerGrounder.LeftGround += OnLeftGround;\n}\n```\n20. Add the OnDisable and OnDestroy methods, which deregister the OnTouchedGround and OnLeftGround handlers. This avoids a memory leak\n```cs\nprivate void OnDisable() {\n    playerGrounder.TouchedGround -= OnTouchedGround;\n    playerGrounder.LeftGround -= OnLeftGround;\n}\n\nprivate void OnDestroy() {\n    playerGrounder.TouchedGround -= OnTouchedGround;\n    playerGrounder.LeftGround -= OnLeftGround;\n}\n```\n21. In the FixedUpdate method, change the jump condition check to include the isGrounded variable\n```cs\nprivate void FixedUpdate() {\n    // ...\n\n    if (isGrounded && shouldJump) {\n        // ...\n    }\n}\n```\n22. Save the script and return to the Unity Editor. Select the player game object in the Hierarchy\n23. Right click on the player game object in the Hierarchy, and select \"Create Empty\". Select the newly created game object, rename it to \"Grounding Collider\", and open it in the Inspector\n24. Click on the Layer combobox near the top of the inspector, and select \"Add Layer\". In the first free User Layer field type \"Ground\". Then, select the \"Grounding Collider\" game object in the Hierarchy, and in the Inspector set its layer to the newly created Ground layer\n25. Select the Plane game object in the Hierachy and also set its layer to the newly created Ground layer. Select once more the \"Grounding Collider\" game object in the Hierarchy\n26. Set the \"Grounding Collider\" transform position to the 0,-0.5,0 (the y component should be -(heightOfPlayerGameObject / 2))\n27. Add a new BoxCollider component and set its size to 1.05,0.05,1.05\n28. Add the  Grounder script component\n29. Select the player game object in the Hierarchy, and find the PlayerMovement component in the Inspector. Drag the \"Grounding Collider\" game object from the Hierarchy into the slot labelled \"Player Grounder\"\n30. Save the scene and press \"Play\" to test the game. You should no longer be able to jump infinitely\n31. Exit play mode when you are finished with testing\n\n"
        },
        {
            "type": "tutstep",
            "title": "Crouching and Sprinting",
            "body": "1. Goto Assets/Scripts in the Project pane and open the PlayerMovement script in your favourite text editor\n2. Before the PlayerMovement class, insert a new enumeration called PlayerMovementState\n```cs\npublic enum PlayerMovementState {\n}\n\n[RequireComponent(typeof(Rigidbody))]\npublic class PlayerMovement : MonoBehaviour { /* ... */ }\n```\n3. Declare the following enumeration values\n```cs\npublic enum PlayerMovementState {\n    Normal,\n    Sprinting,\n    Crouching,\n}\n```\n4. Add the following variables to store sprinting and crouching keys, speeds, and states\n```cs\n[SerializeField] private KeyCode crouchKey;\n[SerializeField] private float crouchingSpeed;\nprivate bool shouldCrouch = false;\n\n[SerializeField] private KeyCode sprintKey;\n[SerializeField] private float sprintingSpeed;\nprivate bool shouldSprint = false;\n```\n5. Create a new property of type PlayerMovementState called State\n```cs\npublic PlayerMovementState State {\n    get {\n        if (shouldSprint)\n            return PlayerMovementState.Sprinting;\n        \n        if (shouldCrouch)\n            return PlayerMovementState.Crouching;\n\n        return PlayerMovementState.Normal;\n    }\n}\n```\n6. In the Update method, add the following lines\n```cs\nprivate void Update() {\n    // ...\n\n    if (Input.GetKeyDown(crouchKey)) {\n        shouldCrouch = true;\n    } else if (Input.GetKeyUp(crouchKey)) {\n        shouldCrouch = false;\n    }\n\n    if (Input.GetKeyDown(sprintKey)) {\n        shouldSprint = true;\n    } else if (Input.GetKeyUp(sprintKey)) {\n        shouldSprint = false;\n    }\n}\n```\n7. In the FixedUpdate method, replace the old rigidbody movement code with the following. Leave the old jumping code in place\n```cs\nprivate void FixedUpdate() {\n    Vector3 relativePositionDelta = (xInput * transform.right) + (zInput * transform.forward);\n\n    switch (State) {\n        case PlayerMovementState.Crouching:\n            relativePositionDelta *= crouchingSpeed;\n            break;\n\n        case PlayerMovementState.Sprinting:\n            relativePositionDelta *= sprintingSpeed;\n            break;\n\n        default:\n            relativePositionDelta *= baseSpeed;\n            break;\n    }\n\n    relativePositionDelta *= Time.fixedDeltaTime;\n    \n    playerRigidbody.MovePosition(transform.position + relativePositionDelta);\n\n    // ...\n}\n```\n8. Save the script and return to the Unity Editor. Select the player game object in the Hierarchy and fill in the new movement related script variables\n9. Save the scene and press \"Play\" to test out the game. You should be able to sprint and crouch using the keys you assigned, with sprinting taking priority over crouching\n10. Exit play mode when you are finished with testing\n\n"
        },
        {
            "type": "tutstep",
            "title": "Creating a Tracking Camera",
            "body": "1. Select the \"Main Camera\" game object in the Hierarchy and drag it onto the player game object to reparent it\n2. Adjust the transform position and rotation to your liking. These will be offsets from the player game object position and rotation respectively\n3. Save the scene and press \"Play\" to test the game. The camera should now track the player\n\nAlternatively this could also have been done using a tracking script on the camera, targeting the player game object transform:\n```cs\nusing UnityEngine;\n\npublic class TransformTracker : MonoBehaviour\n{\n    [SerializeField] private Transform targetTransform;\n    [SerializeField] private Vector3 targetPositionOffset;\n\n    private void Update()\n    {\n        if (targetTransform != null)\n        {\n            transform.position = targetTransform.position + targetPositionOffset;\n        }\n    }\n}\n```\n\nUsing the script-based approach for this simple behaviour, however, wastes CPU time and should only be used for more elaborate tracking behaviours (for example, having the camera revolve around a certain point before being recalled to its original position).\n\n"
        },
        {
            "type": "tutstep",
            "title": "Finishing Off",
            "body": "We start tracking our changed files, and push them to the remote branch:\n```sh\n$ git add .\n$ git commit -m \"Finished workshop 1\"\n$ git push -u origin workshop01\n$ git checkout main\n```\n\nOnce the changes have been pushed, go to your remote git repository and merge the changes onto the main branch. Once the changes have been successfully merged, feel free to go back and delete the (now stale) local workshop01 branch.\n```sh\n$ git branch -d workshop01\n$ git pull\n```\n"
        }
    ]
}