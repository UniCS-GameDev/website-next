{
    "title": "Workshop 03",
    "description": "",
    "thumbnail": "",
    "videoUrl": "https://www.youtube.com/embed/iJTwTcXAxVg",
    "tableOfContents": [
        "Designing a Stats System",
        "Approach",
        "Getting Started",
        "Building the Stats System",
        "Introduction to Unity Events",
        "Becoming Event-driven",
        "Wiring up a UI",
        "Finishing Touches",
        "Creating Stats in Unity",
        "Native Events vs Unity Events",
        "Creating a Healthbar in Unity"
    ],
    "contents": [
        {
            "type": "heading",
            "title": "Errata"
        },
        {
            "type": "infopoint",
            "body": [
                {
                    "type": "tutstep",
                    "title": "EnemyMovement Rotation Issue (14/04/2021)",
                    "body": "During the workshop an issue was uncovered in the rotation for the EnemyMovement script, where an enemy within stopping distance of its target would not face its target. To remedy this, the `EnemyMovement.FixedUpdate` method must be updated to have the following body:\n\n```cs\nprivate void FixedUpdate() {\n    if (Target == null) {\n        return;\n    }\n\n    if (Vector3.Distance(transform.position, Target.position) < StoppingDistance) {\n        Vector3 targetDirection = (Target.position - transform.position).normalized;\n        targetDirection.y = 0; // dont look upwards if the target is above the enemy\n        Quaternion targetRotation = Quaternion.LookRotation(targetDirection);\n        transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, Time.fixedDeltaTime);\n\n        if (!isPaused) {\n            ReachedTarget?.Invoke(transform.position, Resume);\n            isPaused = true;\n        }\n    } else {\n        enemyNavMesh.destination = Target.position;\n    }\n}\n```\n\n\n"
                }
            ]
        },
        {
            "type": "heading",
            "title": "Statistics, Statistics, Statistics..."
        },
        {
            "type": "tutstep",
            "title": "Designing a Stats System",
            "body": "When designing a stats system, as with anything, there are an infinite ways to do the same thing. For our purposes, we will only look at the following 4:\n* Placing all stats related functionality in a dedicated object\n* Placing all stats related functionality in a dedicated script\n* Declaring a base script containing all the stats functionality\n* Declaring an interface describing all the stats functionality\n\n#### Using a separate class or struct\nBy placing all members into a separate Stats class (or struct), we can create a reusable class which can be added onto any script as a member, and which can be used outside of Unity if need be. While initially seeming like a clean separation of the stats code from any underlying parent script, we end up having to proxy calls made on the script to the stats member, meaning that our scripts have lots of methods that do nothing but forward a call. This clutters them up, and can be a hassle to manage.\n\n#### Using a separate script\nUsing a separate script into which all members are places is an alternative to using a separate class. In this way, we avoid having to make many proxy functions, keeping our script relatively slim. The ease of use and easy composition of the first approach is kept, since we can simply add the script to any game object that needs stats functionality. The major downside is that by default all game objects that use this script will share the same behaviour. This may not be desired, since enemies might have their armour work differently to the player. Having different behaviour would require either adding more fields to the stats script, and thereby making it more complex than it needs to be, or using some form of inheritance.\n\n#### Using a base class\nUsing a base class for all scripts using the stats system is another way of implementing it. This would be a script that inherits from `MonoBehaviour`, and has `public` or `protected` members exposing the functionality to later child scripts. On the surface this is similar to the separate script approach, except that scripts wanting to make use of it should inherit not from `MonoBehaviour`, but from this new script class. This approach is unfortunately very limiting, due to C# only allowing inheritance from 1 base class. By inheriting from the stats class, we remove the possibility of inheriting from any further classes, which might be necessary or preferrable later in development. Furthermore, the \"Is A\" relationship established between the new script and the stats script through inheritance is not as applicable as a \"Has A\" relationship. This hints that inheritance might not be the best approach to this problem.\n\n#### Using an interface\nFinally, we could also use an interface. By declaring all the public members that a stats-aware script should have in an interface, we can then implement the interface in any class we want, giving that class stats functionality. This is the most \"decoupled\" approach, but also means that we need to implement a lot of boilerplate code in every class we use the interface with. Furthermore, when we need to make a change to how the system works, we need to edit each implementor of the interface individually, meaning that a lot of changes must me made for a simple tweak. This approach involves the most work.\n\n"
        },
        {
            "type": "tutstep",
            "title": "Approach",
            "body": "For the purposes of the workshop, we will implement the separate Stats script into which all functionality will be placed. This will give us an extensible approach which will compose well with game objects, allowing us to simple add the script to each game object that requires stats. Any edits that would have to be made would be made in 1 place, instead of across multiple scripts. Whilst we wont have enemies and players function differently, this could be achieved using inheritance or other methods.\n\nFor our stats system, we will only include a few basic attributes at the moment, namely Health, Armour, and Experience.\n\n"
        },
        {
            "type": "tutstep",
            "title": "Getting Started",
            "body": "As usual, we start off by creating a branch that will store a snapshot of our\nwork:\n```sh\n$ git branch workshop03\n$ git checkout workshop03\n```\n\nThen, open up the project in the Unity Editor.\n\n"
        },
        {
            "type": "tutstep",
            "title": "Building the Stats System",
            "body": "1. Goto Assets/Scripts in the Project pane and create a new script called \"Stats\". Open it in your favourite text editor\n2. Replace the contents of the script with the following\n```cs\nusing UnityEngine;\n\npublic class Stats : MonoBehvaiour {\n}\n```\n3. Add 3 serialised private variables to store starting health, armour, and experience\n```cs\n[SerializeField] private int baseHealth, baseArmour, baseExperience;\n```\n4. Add the MaxHealth and MaxArmour properties\n```cs\npublic int MaxHealth { get { return baseHealth; } }\npublic int MaxArmour { get { return baseArmour; } }\n```\n5. Add the Health, Armour, and Experience properties\n```cs\npublic int Health { get; set; }\npublic int Armour { get; private set; }\npublic int Experience { get; private set; }\n```\n6. Add the Awake method to set the Health, Armour and Experience properties from the starting values\n```cs\nprivate void Awake() {\n    Health = baseHealth;\n    Armour = baseArmour;\n    Experience = baseExperience;\n}\n```\n7. Save the script and return to the Unity Editor. Add the script as a component to the Player game object and to both the Enemy and Enemy Variant prefabs\n8. Open the Enemy prefab in the prefab editor. Create a new tag called \"Enemy\" or similar and tag the prefab with it. This should set the tag of the base prefab and all variants to Enemy\n9. Create a new empty 3D object under the prefab root, naming it Hitbox. Set its position to 0,0,1\n10. Add a 3D cube collider to the Hitbox prefab element, setting its IsTrigger field to true\n11. Goto Assets/Scripts in the Project pane and create a new script called \"Hitbox\". Open it in your favourite text editor\n12. Replace the contents of the script with the following\n```cs\nusing UnityEngine;\n\n[RequireComponent(typeof(Collider))]\npublic class Hitbox : MonoBehaviour {\n}\n```\n13. Add a Parent property to hold the parent game object of the hitbox\n```cs\npublic GameObject Parent { get; set; }\n```\n14. Add a Damage property to hold the damage the hitbox will deal\n```cs\npublic int Damage { get; set; }\n```\n15. Add the OnTriggerEnter method to deal damage to anything caught in the hitbox. It should not deal damage to entities with the same tag (to prevent friendly-fire with enemies) or to entities lacking the Stats component\n```cs\nprivate void OnTriggerEnter(Collider other) {\n    Stats enemyStats = other.GetComponent<Stats>();\n\n    if (CompareTag(other.tag) || enemyStats == null) return;\n\n    int damage = enemyStats.Armour > Damage ? 0 : (Damage - enemyStats.Armour);\n\n    Debug.Log($\"Dealing {damage} damage to {other.gameObject.name}\");\n\n    enemyStats.Health -= damage;\n}\n```\n16. Save the script and return to the Unity Editor. Add the script as a component to the Hitbox prefab game object\n17. Goto Assets/Scripts in the Project pane and open the EnemyBehaviourMelee script in your favourite text editor\n18. Add new serialised private variables to store the damage dealt and a reference to the Hitbox script (and game object)\n```cs\n[SerializeField] private int damage;\n[SerializeField] private Hitbox hitbox;\n```\n19. Extend the AttackCoroutine method to enable and disable the hitbox when appropriate\n```cs\nprivate IEnumerator AttackCoroutine(Action resumeTrackingCallback) {\n    hitbox.Parent = gameObject;\n    hitbox.Damage = damage;\n\n    hitbox.gameObject.SetActive(true);\n    yield return new WaitForSeconds(AttackCooldown);\n    hitbox.gameObject.SetActive(false);\n\n    resumeTrackingCallback();\n}\n```\n20. Save the script and return to the Unity Editor. Enter play mode to test out the script. The melee enemy should walk up to the player when they get in range, and when attacking the message \"Dealing N damage to Player\" should show up in the console (where N is an integer)\n\n"
        },
        {
            "type": "tutstep",
            "title": "Introduction to Unity Events",
            "body": "Having already seen native C# events, we should also cover the Unity variant. Unity events are very similar to the classic C# events, exposing an `AddListener` method equivalent to the native event's `+=` operation. They also expose an `Invoke` method, and various method to access the registered listeners (and also clear all listeners). This is a great deal more than the simple `+=` and `-=` of native events, however it also means that you can run into unexpected behaviour (specifically if you accidentally call `RemoveAllListeners` when you dont mean to).\n\nThe performance of the two event systems are comparable, with C# events generally being lower-overhead and faster than Unity events. Some random benchmarks found off the internet can be found [here](https://www.jacksondunstan.com/articles/3335). Unity events do some more housekeeping, which explains the additional overhead.\n\nUnity events are more powerful than native events, and since they use weak references internally they allow the GC to collect stale objects, preventing a common memory leak; they prevent you forgetting to unsubscribe all handlers from an event before its parent script is destroyed. Unity events also have a fancy GUI widget in the Editor, allowing you to hook them up not only in code but also in the designer. Any handlers assigned in the designer are called \"persistent\" handlers, and wont be unassignable (even through a call to `RemoveAllListeners`).\n\n"
        },
        {
            "type": "tutstep",
            "title": "Becoming Event-driven",
            "body": "1. Goto Assets/Scripts and open the Hitbox script in your favourite text editor\n2. Extend the OnTriggerEnter method to simply send an event, without doing any calculation\n```cs\nprivate void OnTriggerEnter(Collider other) {\n    Stats enemyStats = other.GetComponent<Stats>();\n\n    if (CompareTag(other.tag) || enemyStats == null) return;\n\n    Debug.Log($\"Dealing {Damage} damage to {other.gameObject.name}\");\n\n    enemyStats.DamageListener.Invoke(Damage);\n}\n```\n3. Save the script and open the Stats script. Add a new inner class, calling it DamageEvent\n```cs\n[Serializable]\npublic class DamageEvent : UnityEvent<int> { }\npublic DamageEvent DamageListener;\n```\n4. Add the OnTakeDamage method, moving the calculation from the hitbox to the stats script. At this point, the `Health` property should have its setter made private\n```cs\npublic int Health { get; private set; }\n// ...\nprivate void OnTakeDamage(int rawDamage) {\n    int damage = Armour > rawDamage ? 0 : (rawDamage - Armour);\n\n    Health -= damage;\n}\n```\n5. Add the Start method\n```cs\nprivate void Start() {\n    if (DamageListener == null) DamageListener = new DamageEvent();\n    DamageListener.AddListener(OnTakeDamage);\n}\n```\n6. Save the script and return to the Unity Editor. Enter play mode to test the new implementation. It should work the same as before\n\n"
        },
        {
            "type": "tutstep",
            "title": "Wiring up a UI",
            "body": "Having designed and implemented our stats system, with the player taking damage from enemies, we might now want to have some way of seeing the players current health, armour, and experience. Thus we might want to build a GUI for the player.\n\nOne of the problems that we quickly encounter is the need to reference the player game object's internal state from multiple places. Taking the Stats component, we need to hold a reference to it in both the player object (so that we can be attacked by enemies) and in the UI (to display health or experience). This means we need to decide who gets the \"master copy\" of the stats, and who gets a reference to the stats. In our case, we will ensure that the player object always holds the original copy of the stats and the UI simply holds a reference, but it could be done the other way around as well.\n\nAlso of note is the fact that in our game, we will only ever have a single interactive player object. Thus, we can hold player state in a singleton player \"controller\" component and have the state persist through multiple scenes by calling `DontDestroyOnLoad` in the controller.\n\n1. Goto Assets/Scripts in the Project pane and create a new script called \"PlayerController\". Open it in your favourite text editor\n2. Replace the contents of the script with the following\n```cs\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour {\n}\n```\n3. Add a new static private variable to hold the singleton instance of the player controller\n```cs\nprivate static PlayerController instance;\n```\n4. Add 2 serialised private variables to hold a reference to the player stats component and the player display component (which controls the UI)\n```cs\n[SerializeField] private Stats stats;\n[SerializeField] private PlayerDisplay hud;\n```\n5. Add the Awake method to set the instance and mark it as non-destructible, or to destroy excess instances\n```cs\nprivate void Awake() {\n    if (instance != null) {\n        Destroy(gameObject);\n    } else {\n        instance = this;\n        DontDestroyOnLoad(gameObject);\n    }\n}\n```\n6. Add the OnEnable and OnDisable methods to handle setting up references for the UI and tearing them down\n```cs\nprivate void OnEnable() {\n    hud.SetupReferences(stats);\n}\n\nprivate void OnDisable() {\n    hud.TeardownReferences(stats);\n}\n```\n7. Save the script and return to the Unity Editor. Add the PlayerController script component to the Player game object, and drag the player game object's Stats component onto the Stats field\n8. Goto Assets/Scripts in the Project pane and create a new script called \"PlayerDisplay\". Open it in your favourite text editor\n9. Replace the contents of the script with the following\n```cs\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class PlayerDisplay : MonoBehaviour {\n}\n```\n10. Add a new serialised private variable to store a reference to the healthbar slider\n```cs\n[SerializeField] private Slider healthSlider;\n```\n11. Add a new private variable to store a reference to the player stats object\n```cs\nprivate Stats currentStats;\n```\n12. Add the SetupReferences and TeardownReferences methods to set the currentStats reference and assign event handlers\n```cs\npublic void SetupReferences(Stats playerStats) {\n    currentStats = playerStats;\n    healthSlider.maxValue = playerStats.MaxHealth;\n    healthSlider.value = playerStats.Health;\n    playerStats.DamageListener.AddListener(OnHealthUpdate);\n}\n\npublic void TeardownReferences(Stats playerStats) {\n    currentStats = null;\n    playerStats.DamageListener.RemoveListener(OnHealthUpdate);\n}\n```\n13. Add the OnHealthUpdate handler method to update the health slider\n```cs\nprivate void OnHealthUpdate(int damage) {\n    healthSlider.value = currentStats != null ? currentStats.Health : 0;\n}\n```\n14. Save the script and return to the Unity Editor. Add the PlayerDisplay script component to the Player game object, and drag it onto the PlayerController's Hud field\n15. Add a new UI > EventSystem game object to the scene root\n16. Add a new UI > Canvas game object as a child of the Player object. Name it HUD or similar\n17. Right click on the Canvas and add an empty game object. This will create an empty UI object, and will give it the Rect Transform needed for all properly functioning UI elements. Name it \"Healthbar\" or similar\n18. Set the anchor of the Healthbar game object to the top left corner of the screen. This can be done using the selector, or by setting the minimum and maximum anchors to 0,1 (x,y)\n19. Set the pivot to be the top left corner of the screen. This can be done using the selector, or by setting the pivot to 0,1 (x,y)\n20. Set the position to 0,0,0 and the width,height to be 200,20\n21. Add a new UI > Image as a child of the Healthbar game object. Name it \"Background\" and anchor it to stretch to fill the parent UI element. This can be done in the selector, or by setting the minimum anchor to 0,0 and the maximum anchor to 1,1\n22. Add a new UI > Image as a child of the Healthbar game object. Name it \"Foreground\" and anchor it to stretch to fill the parent UI element. This can be done in the selector, or by setting the minimum anchor to 0,0 and the maximum anchor to 1,1. Set its Image > Color to red, or another colour of your choosing\n23. Add a slider component to the Healthbar game object. Set interactable to false and drag the Foreground game object onto the Fill Rect field\n24. Drag the Healthbar game object onto the \"Health Slider\" field in the player's PlayerDisplay script component. Enter Play mode to test the game\n\n"
        },
        {
            "type": "tutstep",
            "title": "Finishing Touches",
            "body": "We start tracking our changed files, and push them to the remote branch:\n```sh\n$ git add .\n$ git commit -m \"Finished workshop 3\"\n$ git push -u origin workshop03\n$ git checkout main\n```\n\nOnce the changes have been pushed, go to your remote git repository and merge the changes onto the main branch. Once the changes have been successfully merged, feel free to go back and delete the (now stale) local workshop01 branch.\n```sh\n$ git branch -d workshop03\n$ git pull\n```\n\n"
        },
        {
            "type": "heading",
            "title": "Additional Resources"
        },
        {
            "type": "tutstep",
            "title": "Creating Stats in Unity",
            "body": "An alternative stat system implementation by Brackeys: [https://www.youtube.com/watch?v=e8GmfoaOB4Y](https://www.youtube.com/watch?v=e8GmfoaOB4Y)\n\n"
        },
        {
            "type": "tutstep",
            "title": "Native Events vs Unity Events",
            "body": "Benchmarks comparing native C# events to Unity events: [https://www.jacksondunstan.com/articles/3335](https://www.jacksondunstan.com/articles/3335)\n\n"
        },
        {
            "type": "tutstep",
            "title": "Creating a Healthbar in Unity",
            "body": "A Healthbar implementation by Brackeys: [https://www.youtube.com/watch?v=BLfNP4Sc_iA](https://www.youtube.com/watch?v=BLfNP4Sc_iA)\n"
        }
    ]
}